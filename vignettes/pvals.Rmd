---
title: "Meta-analytic combination of p-values"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{Meta-analytic combination of p-values}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library("metagam")
library("mgcv")
library("metafor")
library("ggplot2")
theme_set(theme_bw())
```

Previous versions of metagam had built-in aggregation of p-values, using the [metap](https://cran.r-project.org/package=metap) package. However, this had two drawbacks:

- metap depends on multtest, which is a Bioconductor package, and this dependency made the installation of metagam unnecessarily complicated.
- Aggregation of p-values might not always make sense for smooth terms. (Thanks to Alexandre Loureiro for discovering this!)

This vignette briefly describes the latter issue, and shows how the metap package can be used directly on output from metagam.

## What can go wrong when combining p-values?

Consider the two datasets below, which have completely opposite effects. I have also included the code for simulating the data.

```{r, echo=FALSE}
simulate_data <- function(){
  dat1 <- data.frame(x = runif(100))
  dat1$y <- dat1$x + rnorm(100, sd = .7)
  
  dat2 <- dat1
  dat2$y <- -dat2$x + .1 * dat2$x^2 + rnorm(100, sd = .7)
  
  list(dat1 = dat1, dat2 = dat2)
}
set.seed(1)
dd <- simulate_data()

ggplot(dd$dat1, aes(x = x, y = y)) + 
  geom_point() + 
  ggtitle("Dataset 1")

ggplot(dd$dat2, aes(x = x, y = y)) + 
  geom_point() + 
  ggtitle("Dataset 2")

```

Fitting a GAM to each dataset separately, we see that the effect is significant at $\alpha = 0.05$ level.

```{r}
mod1 <- gam(y ~ s(x, bs = "cr"), data = dd$dat1)
summary(mod1)

mod2 <- gam(y ~ s(x, bs = "cr"), data = dd$dat2)
summary(mod2)
```

Now let us try a metagam fit.

```{r}
models <- list(strip_rawdata(mod1), strip_rawdata(mod2))
metafit <- metagam(models)
```

Plotting the meta-analytic fit, we see that the 95 % confidence bands completely cover zero.

```{r}
ggplot(metafit$meta_estimates, aes(x = x, y = estimate, ymin = ci.lb, ymax = ci.ub)) + 
  geom_line() + 
  geom_ribbon(alpha = .3) + 
  geom_hline(yintercept = 0, linetype = "dashed")
```

The object returned by `metagam` has a `meta_pvals` element which contains p-values for each term in each individual fit. In this case we have only a single term. 

```{r}
metafit$meta_pvals
```
We extract the p-values by looking into the `data` object.

```{r}
metafit$meta_pvals$data[[1]]
pvals <- metafit$meta_pvals$data[[1]]$`p-value`
```


Combining the p-values using any of the methods available in metap, we do however see that the effects are signficiant at $\alpha = 0.05$. 

```{r, eval=FALSE}
library("metap")
allmetap(p = pvals, method = "all")
```

```{r, echo=FALSE}
structure(list(p = list(logitp = 5.61819601706602e-07, maximump = 1.25713383795263e-06, 
    meanp = NA_real_, meanz = 6.75835070011165e-08, minimump = 7.22516917847225e-06, 
    sumlog = 8.23242533258099e-08, sump = 6.32623953067482e-07, 
    sumz = structure(4.8107525303013e-08, .Dim = c(1L, 1L))), 
    valid = list(logitp = 2L, maximump = 2L, meanp = 2L, meanz = 2L, 
        minimump = 2L, sumlog = 2L, sump = 2L, sumz = 2L), eponym = c("", 
    "", "", "", "Tippett", "Fisher", "Edgington", "Stouffer")), row.names = c("logitp", 
"maximump", "meanp", "meanz", "minimump", "sumlog", "sump", "sumz"
), class = c("allmetap", "data.frame"))
```

This happens because combination of p-values is not aware of the direction of the effects. Hence, rather than having this a part of the package, we suggest that users who know what they're doing combine the p-values using metap package.

For comparison, fitting a linear model to each dataset and combining the slopes using `metafor` gives a p-value 0.9296, which makes a lot more sense.

```{r}
mod1 <- lm(y ~ x, data = dd$dat1)
mod2 <- lm(y ~ x, data = dd$dat2)

estimates <- c(coef(mod1)[["x"]], coef(mod2)[["x"]])
sampling_variances <- c(vcov(mod1)[["x", "x"]], vcov(mod2)[["x", "x"]])
rma(estimates, vi = sampling_variances)
```


## A better way to compute p-values?

### Simultaneous confidence intervals

Let's create another GAM fit, this time using the `gamSim` function. The dashed lines in the plot correspond to two standard errors above and below the estimate. However, this is a pointwise confidence interval, which for our practical purposes means that under repeated sampling from the population, it will contain the true function less than 95 % of the times. See, e.g., Chapter 6.5 of @Ruppert2003, @Sorensen2021b or [this blog post](https://fromthebottomoftheheap.net/2016/12/15/simultaneous-interval-revisited/). What we need is a simultaneous confidence interval.

```{r}
set.seed(123)
dat <- gamSim(verbose = FALSE)
mod <- gam(y ~ s(x0, bs = "cr"), data = dat)
plot(mod)
```



```{r, echo=TRUE}
getmasd <- function(mod, grid, nmc = 10000){
  Vb <- vcov(mod)
  pred <- predict(mod, grid, se.fit = TRUE)
  se.fit <- pred$se.fit
  
  BUdiff <- rmvn(nmc, mu = rep(0, nrow(Vb)), V = Vb)
  Cg <- predict(mod, grid, type = "lpmatrix")
  simDev <- Cg %*% t(BUdiff)
  absDev <- abs(sweep(simDev, 1, se.fit, FUN = "/"))
  apply(absDev, 2L, max)
}
```

We see that the critical value for a 95 % simultaneous interval is above 2.

```{r}
grid <- with(dat, data.frame(x0 = seq(min(x0), max(x0), length = 200)))
masd <- getmasd(mod, grid)
(crit <- quantile(masd, prob = .95, type = 8))
```


We can plot the two together, and we see that the simultaneous confidence interval is bigger.

```{r}
fit <- predict(mod, newdata = grid, se.fit = TRUE)
dat <- data.frame(
  x0 = grid$x0,
  pred = fit$fit,
  ci_pt_lb = fit$fit + qnorm(.025) * fit$se.fit,
  ci_pt_ub = fit$fit + qnorm(.975) * fit$se.fit,
  ci_sim_lb = fit$fit - crit * fit$se.fit,
  ci_sim_ub = fit$fit + crit * fit$se.fit
)

ggplot(dat, aes(x = x0, y = pred)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ci_pt_lb, ymax = ci_pt_ub), alpha = .3) + 
  geom_ribbon(aes(ymin = ci_sim_lb, ymax = ci_sim_ub), alpha = .3)
```

### Combining simultaneous confidence intervals

More will come here when package is further developed.




# References








